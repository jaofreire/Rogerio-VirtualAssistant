@page "/"
@using System.Text.Json
@rendermode InteractiveServer
@inject IJSRuntime JsRuntime
@inject IConfiguration Configuration
@inject IWeatherAPIIntegration WeatherAPIIntegration

<PageTitle>Rogério</PageTitle>

<h1>Fale com o Rogério</h1>
@if (isListening)
{
    <button class="btn btn-danger" @onclick="Talk">Parar de falar</button>
}
else
{
    <button class="btn btn-primary" @onclick="Talk">Aperte para falar</button>
}

<div>
    <p class="fw-bold">Pergunta:</p>
    <p>@question</p>
</div>

<div>
    <p class="fw-bold">Resposta</p>
    <p>@answer</p>
</div>

<script>

    function startListening(dotNetRef){
        const recognition = new window.webkitSpeechRecognition();
        recognition.lang = 'pt-BR';
        recognition.continuous = false;
        recognition.interimResults = false;

        recognition.onresult = (e) => {
            let text = e.results[0][0].transcript;
            dotNetRef.invokeMethodAsync("ReceiveSpeechText", text);
            console.log(text);
        };

        recognition.onerror = (e) => {
            console.log("Erro ao reconhecer a voz", e.error);
        }

        recognition.start();
    }

    function sendTextToGPT(preRequisites, prompt, dotNetRef, apiKey, modelType){
        const requestBody = {
            model: modelType,
            messages : [
                {
                    role: "developer",
                    content: preRequisites
                },
                {
                    role: "user",
                    content: prompt
                }
            ],
            functions: [
                {
                    name: "bom_dia",
                    description: "Será chamado quando o prompt do usuário tiver algo relacionado a 'Bom dia, Rogério'"
                }
            ]
        }

         fetch("https://api.openai.com/v1/chat/completions", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + apiKey
            },
            body: JSON.stringify(requestBody)
        })
        .then((response) => response.json())
        .then(async (jsonData) => {
            console.log(jsonData);

            if (jsonData.choices[0].message.function_call) {
                const functionCall = jsonData.choices[0].message.function_call;

                if (functionCall.name === "bom_dia") {
                   await dotNetRef.invokeMethodAsync("BomDiaCallFunction");
                }
            }

            const text = jsonData.choices[0].message.content;
            dotNetRef.invokeMethodAsync("ReceiveIAReponse", text);
        })
        .catch((error) => console.log("Ocorreu um erro ao chamar a API da OpenAI", error))
    }


    function sendTextToGemini(prompt, dotNetRef, apiKey){
        const requestBody = {

            contents: [{
                parts: [{text: prompt }]
            }]

        };

        fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=" + apiKey, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(requestBody) 
        })
            .then((response) => response.json())
            .then((jsonData) => {
                console.log(jsonData);
                const text = jsonData.candidates[0].content.parts[0].text;
                console.log(text);
                dotNetRef.invokeMethodAsync("ReceiveIAReponse", text);
            })
            .catch((error) => console.log("Ocorreu um erro ao chamar a API da gemini",error)); 
    }

</script>

@code{
    private bool isListening = false;
    private string question = "";
    private string answer = "";

    private string apiKey = "";

    protected override void OnAfterRender(bool firstRender)
    {
        apiKey = Configuration["OpenIA:ApiKey"]!;    
    }

    private async Task Talk()
    {
        isListening = !isListening;

        if (isListening)
        {
            var dotNetRef = DotNetObjectReference.Create(this);
            await JsRuntime.InvokeVoidAsync("startListening", dotNetRef);
        }

    }

    [JSInvokable]
    public async Task ReceiveSpeechText(string questionText)
    {
        isListening = false;
        question = questionText;
        StateHasChanged();

        var inputPrompt = PromptUtils.GeneratePrompt(questionText);

        await SendTextToIA(inputPrompt.PreRequisites, inputPrompt.Prompt);
    }

    public async Task SendTextToIA(string preRequisites, string userPrompt)
    {
        string modelType = "gpt-4o-mini";
        var dotNetRef = DotNetObjectReference.Create(this);

        await JsRuntime.InvokeVoidAsync("sendTextToGPT", [preRequisites, userPrompt, dotNetRef, apiKey, modelType]);
    }

    [JSInvokable]
    public void ReceiveIAReponse(string response)
    {
        answer = response;
        StateHasChanged();
    }

    [JSInvokable]
    public async Task BomDiaCallFunction()
    {
        var currentWeatherResponse = await WeatherAPIIntegration.GetCurrentWeather("Recife");
        string jsonReponse = JsonSerializer.Serialize(currentWeatherResponse);

        var inputPrompt = PromptUtils.GenerateBomdiaCallFunctionPrompt(jsonReponse);
        await SendTextToIA(inputPrompt.PreRequisites, inputPrompt.Prompt);
    }
}
